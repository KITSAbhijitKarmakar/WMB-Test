BROKER SCHEMA com.kingfisher.ukbq.errorhandlers
-- ************************************************************************************
-- * ESQL for the ErrorHandler message flow
-- ************************************************************************************
-- * 12/03/2012 - C Russell
-- * 24/09/2012 - Angus Cooke - corrections and modifications.
-- *
-- * Format Error Log Messages
-- ************************************************************************************
CREATE COMPUTE MODULE ErrorHandler_FormatErrorLog
	
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
						
		--Declare the namespace for destination Log object
		DECLARE ErrorLogns NAMESPACE 'http://www.ibm.com/dfdl/CommaSeparatedFormat';			
		-- Set the Output Local Environment to the Input.
		SET OutputLocalEnvironment = InputLocalEnvironment;
		-- Set the Output Diagnostic Message's Format to be DFDL.
		SET OutputRoot.Properties.MessageFormat = 'DFDL';
		-- Set the Output Exception List to  the Input.
		SET OutputExceptionList = InputRoot.MQRFH2.usr.ExceptionList;

		-- Create an DFDL part of the message tree
        CREATE NEXTSIBLING OF OutputRoot.Properties DOMAIN('DFDL');

		--Set Timestamp,BrokerName and EG values
		SET OutputRoot.DFDL.ErrorLog.record.Timestamp = CURRENT_TIMESTAMP;
		SET OutputRoot.DFDL.ErrorLog.record.BrokerName = BrokerName;
		SET OutputRoot.DFDL.ErrorLog.record.ExecutionGroup = ExecutionGroupLabel;
		
		--Set Message flow name without the preceeding namespace and application references
		DECLARE i INTEGER;
		SET i = POSITION ('.' IN  MessageFlowLabel REPEAT -1);
		SET OutputRoot.DFDL.ErrorLog.record.MessageFlowName = SUBSTRING(MessageFlowLabel FROM i+1);
				
		--Set MsgID by using the BLOB value when we put the original message to the WMQ Error queue	
		DECLARE msgIDBLOB CHARACTER;
		SET msgIDBLOB = OutputLocalEnvironment.WrittenDestination.MQ.DestinationData.correlId;
		IF STARTSWITH (msgIDBLOB , 'X')
			THEN SET msgIDBLOB = SUBSTRING (msgIDBLOB FROM 2);
		END IF; 
		SET OutputRoot.DFDL.ErrorLog.record.CorrelID = msgIDBLOB;
						
		--Set Error Description by calling procedure to loop through Exception list
		DECLARE messageText   CHARACTER '';
		Call getLastExceptionDetail(OutputExceptionList, messageText);
	
		--Set ErrorType and localTransactionId	
		SET OutputRoot.DFDL.ErrorLog.record.ErrorType = messageText;
						
		RETURN TRUE;
	END;

	--Procedure to get the relevant exception details
	CREATE PROCEDURE getLastExceptionDetail(IN    InputTree     REFERENCE,
											INOUT messageText   CHAR)	

    /*********************************************************************************************
	* A procedure that will get the details of the last exception from a message
	*
	* IN InputTree:  The incoming exception list
	* INOUT messageText: The last message text.
	**********************************************************************************************/
	BEGIN
   	    -- Create a reference to the first child of the exception list
   	    DECLARE currentException REFERENCE TO InputTree.*[1];
   	    DECLARE msgTextShort	 CHARACTER '';
   	    DECLARE msgErrorNumber 	 CHARACTER '';
   	    
   	    -- keep looping while the moves to the child of exception list work 
		WHILE lastmove(currentException) DO
			-- store the current values for the error number and text
			IF (currentException.Number IS NULL) THEN
				IF (currentException.Text IS NOT NULL) THEN
					SET messageText = currentException.Text;
				END IF;
			END IF;
			
			IF (currentException.Number IS NOT NULL) THEN
        		SET msgTextShort   = currentException.Text;
        		SET msgErrorNumber = CAST(currentException.Number AS CHARACTER);
        	END IF;
        	
  			-- now move to the last child which should be the next exceptionlist
			MOVE currentException LASTCHILD;
		END WHILE; 
		
		SET messageText = msgTextShort || ':' || messageText || ':' || msgErrorNumber;
		
   	END;
  
END MODULE;

-- ************************************************************************************
-- * ESQL for the ErrorHandler message flow
-- ************************************************************************************
-- * 12/03/2012 - C Russell (Based on the code provided by Tony Cox(IBM))
-- * Format Message and exception for MQ Archive Queue
-- *
-- * 07/09/2012 - Modified for Record & Replay - Angus Cooke
-- ************************************************************************************
CREATE COMPUTE MODULE ErrorHandler_Format_MQ_Messages
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
				
		CALL CopyEntireMessage();
				
		DECLARE ReplayQueue CHARACTER 'NotFound';
        
		-- Check to see if MQMD header exists (Has this message data originated from an MQ Input source?)
		IF EXISTS(InputRoot.MQMD[]) THEN
						
			--If Yes, then set MQMD.CorrelID to MQMD.MsgID
			SET OutputRoot.MQMD.CorrelId = OutputRoot.MQMD.MsgId;
			SET ReplayQueue = OutputRoot.MQMD.SourceQueue; 
			
		ELSE
			--If No, then create a new correlId
			DECLARE generatedCorrelationId CHARACTER; 
			SET generatedCorrelationId = SUBSTRING(UUIDASCHAR FROM 1 FOR 24); 
								
			--Sets other MQ header data
			CREATE NEXTSIBLING OF OutputRoot.Properties DOMAIN ('MQMD');
			
			SET OutputRoot.MQMD.MsgId          = MQMI_NONE;
			SET OutputRoot.MQMD.MsgType        = MQMT_DATAGRAM;
			SET OutputRoot.MQMD.CodedCharSetId = 1208;
			SET OutputRoot.MQMD.Format         = MQFMT_NONE;
			SET OutputRoot.MQMD.CorrelId       = CAST(generatedCorrelationId AS BLOB CCSID 1208); 
			  
		END IF;	

		-- Check that there is an RFH2 present, otherwise create one for output
		IF (InputRoot.MQRFH2 IS NULL) THEN
			CALL CommonAddRFH2(OutputRoot);
		END IF;

		--Sets some of the Output properties
		SET OutputRoot.Properties.Persistence = true;
        SET OutputRoot.Properties.ExpirationTime = -1;
        			
		-- Sets where and when the error occured plus the replay Queue
		-- Check to see if this an error from the replay flow itself and indicate this if it was
		IF (ReplayQueue = 'REPLAY.FLOW.WMB') THEN
			SET OutputRoot.MQRFH2.usr.ThrownFromReplayFlow = 'true';
		ELSE
			SET OutputRoot.MQRFH2.usr.ReplayQueue = ReplayQueue;
		END IF;
		
		SET OutputRoot.MQRFH2.usr.Broker.brokerName         = BrokerName;
		SET OutputRoot.MQRFH2.usr.Broker.executionGroupName = ExecutionGroupLabel;
		SET OutputRoot.MQRFH2.usr.Broker.flowName           = MessageFlowLabel;
		SET OutputRoot.MQRFH2.usr.Broker.TimeStamp          = SUBSTRING(CAST(CURRENT_TIMESTAMP AS CHAR) FROM 12 FOR 23);
		
		-- Sets other useful diagnostic information
		SET OutputRoot.MQRFH2.usr.Broker.Environment      = Environment;
		SET OutputRoot.MQRFH2.usr.Broker.LocalEnvironment = InputLocalEnvironment;
		                 	
	    -- Store the exception list 	
		SET OutputRoot.MQRFH2.usr.ExceptionList = InputExceptionList;
								
		RETURN TRUE;
	END;
	
	--CopyEntireMessage Procedure
	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END; 

	CREATE PROCEDURE CommonAddRFH2(IN OutputRoot REFERENCE) 
	BEGIN 
		CREATE NEXTSIBLING OF OutputRoot.MQMD DOMAIN 'MQRFH2';
		SET OutputRoot.MQMD.Format = MQFMT_RF_HEADER_2;
		SET OutputRoot.MQRFH2.(MQRFH2.Field)Version = MQRFH_VERSION_2; 
		SET OutputRoot.MQRFH2.(MQRFH2.Field)Format = MQFMT_STRING; 
		SET OutputRoot.MQRFH2.(MQRFH2.Field)NameValueCCSID = 1208; 
	END;

END MODULE;